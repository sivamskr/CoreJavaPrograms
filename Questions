> What is class loader and how to use this?
 class loader is responsible to load that class file from file system,network or any other location. This class loader is nothing but  also a class from which location they are loading the class according to that class loaders are three types :

 1.Bootstrap  
 2.Extension  
 3.System class loader 
 [http://javarevisited.blogspot.sg/2012/12/how-classloader-works-in-java.html]

OOPS -   A PIE
------------------  
> Abstraction   :  defining an idea in terms of classes or interface                  ; abstract  -  interface
> Polymorphism  :  function in multiple forms                                         ; Overwriting - Overloading
> Inheritance   :  inherit properties from its parent class                           ; extend - implement
> Encapsulation :  combining  methods n attribute into a class(hide how things work)  ; public - default - protected -private

> Difference between == and equals() method ?
  == is used to compare both primitive and objects while equals() is only used for objects comparison.
  "==" compare two objects based on memory reference
  Default implementation of equals provided in Object class is similar to "==" equality operator and return true if you are comparing   two references of same object. 
  
> Difference between == and equals() method in String ? 
  Since java.lang.String class override equals method, It return true if two String object contains same content but == will only       return true if two references are pointing to same object.
  
  String personalLoan = new String("== and equals");
  String homeLoan = new String("== and equals");
       
  //since two strings are different object result should be false
  personalLoan == homeLoan;        # False

  //since strings contains same content , equals() should return true
  personalLoan.equals(homeLoan);   #True

> Difference between equals() and hashCode() ?
  To put entry in HashMap, first hashcode is calculated and this hashcode used to find bucket(index) where this entry will get stored   in hashMap.
  
  
> Difference between "Transient and "Volatile" ?
  transient keyword is used during serialization of Java object   :exclude them from serialization process
  volatile is related to visibility of variables modified by multiple thread during concurrent programming. 

> String

 -String vs StringBuffer, 
 -String object is immutable
 -StringBuffer/StringBuilder objects are mutable.
 
> Difference between String literal and String object
  String literal checks if the variable is already there in string pool, If it exists, it points to the same liters
  new() operator always creates a new String object.
  String a = "Java"; 
  String b = "Java"; 
  System.out.println(a == b); // True
  I think up-to Java 1.6 String pool is located in permgen area of heap, but in Java 1.7 updates its moved to main heap area.
  
> Comparator and Comparable in Java



SimpleDateFormat is used to convert Dates to String and vice-versa.
  SimpleDateFormat sdf = new SimpleDateFormat("yyyy/MM/DD HH:mm:ss");
  Date curdate= new Date();
  System.out.println(sdf.format(curdate));


Collections 
- iterable interface present in java.lang package not in java.util package 

    Set(no duplicates) ::  Queue   :: List(inseration order)     ::   Map(key value pair)

                      add()                                               put()
    HashSet                           ArrayList                       HashMap  
    TreeSet                           Linked List                     TreeMap
                                      Vector                          Hashtable


  import java.util.Hashtable;
  import java.util.Iterator;
  import java.util.Map;
  import java.util.Map.Entry;
  import java.util.Set;
  
  Iterator<Entry<Integer, String>> i= stockSet.iterator();
  System.out.println("Iterating over Hashtable in Java");
  
  //Iterator begins
  while(i.hasNext()){
    Map.Entry<Integer,String> m=i.next();
    int key = m.getKey();
    String value=m.getValue();
    System.out.println("Key :"+key+"  value :"+value);
  }



ArrayList and HashSet 
- index based  use get(index) and remove(index)
- object based. HashSet also doesn't provide get() method


ArrayList vs LinkedList
- ArrayList is backed by Array while LinkedList is backed by LinkedList
- ArrayList is better choice than LinkedList in almost all cases, except when you do a frequent add() operation than remove() or get().


ArrayList vs Vector

HashMap vs Hashtable

To use any object as key in HashMap , it needs to implement equals() and hashCode() method .


Threads  : 




Serialization : 

> Difference between Serializable and Externalizable in Java Serialization
  In case of Serializable, default serialization process is used. while in case of Externalizable custom Serialization process is used   which is implemented using readExternel() and writeExternal() 




Streams
  byte stream :  For reading and writing binary data


  Character streams : work with the characters 

Design Pattern

Double checked locking in Singleton
private DCL dcl = null; 
 public DCL getDCL() {
      if (dcl == null) {    #insted of creating an object directly we double check to create an instance
      synchronized { 
         if (dcl == null) 
            dcl = new DCL(); 
       } 
     } 





